package com.lyp.algorithm;

/**
 * 三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。 结果可能很大，你需要对结果模1000000007。
 *
 * 示例1:
 *
 * 输入：n = 3 输出：4 说明: 有四种走法 示例2:
 *
 * 输入：n = 5 输出：13 n=61 输出  752119970
 */
public class ThreeStepProblem{

  public static long waysToStep(int n){

    int[] aa = {0, 1, 2, 4};

    if(n < 4){
      return aa[n];
    }

    for(int i = 4; i <= n; i++){
      // 结果可能很大，你需要对结果模 1000000007,
      // 这里涉及到模运算： (a + b) % p = (a % p + b % p) % p。当然不考虑溢出的话，计算应该是求出未模过的三个值然后：(a+b+c)%1000000007
      // 但是考虑溢出的话需要转化一下： ((a + b) % p + c % p) % p 下面的 aa[3]由于不可能大于 1000000007 可以省略 %1000000007。
      // 再就是取模的传递，需要思考为什么（循环的每一次取模）与（中间不取模而只在最后取模结果）是一样的？
      // 其实还是模运算公式： (a + b) % p = (a % p + b % p) % p 的无限细化，
      // 如： a=a1+b1就会有 ((a1+b1) % p + b % p) % p --> ((a1 % p + b1 % p) % p + b % p) % p
      // 这个过程倒推就是只在最后一次取模与，中间每一次求和取模结果是一样的。

      // (a+b+c)%1000000007 = ((a+b)+c)%1000000007 = ((a+b)%1000000007 + c%1000000007)%1000000007

      aa[0] = ((aa[1] + aa[2]) % 1000000007 + aa[3]) % 1000000007;
      aa[1] = aa[2];
      aa[2] = aa[3];
      aa[3] = aa[0];
    }
    return aa[3];
  }

  public static void main(String[] args){
    System.out.println(waysToStep(61));
  }
}